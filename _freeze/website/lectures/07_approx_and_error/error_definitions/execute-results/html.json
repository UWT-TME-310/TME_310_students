{
  "hash": "8b212be7718f0a3f54bc85630c6888ca",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Error definitions\"\nsubtitle: \"TME 310 - Computational Physical Modeling\"\nauthor: \n  - \"Lorne Arnold, PhD, PE\"\ninstitute: \"University of Washington Tacoma\"\nformat:\n  revealjs:\n      logo: \"\"\n---\n\n## Absolute and relative error (true)\n\n:::{.fragment}\nThe true *absolute* error, $E_t$, is the difference between the true value and our approximation:\n\n$$E_t = \\text{true} - \\text{approx}$$\n:::\n\n:::{.fragment}\nThe true *relative* error, $\\epsilon_t$ is:\n\n$$\\epsilon_t = \\frac{\\text{true} - \\text{approx}}{\\text{true}} (\\text{often}\\times 100\\%)$$\n:::\n\n:::{.fragment}\n$$\\epsilon_t = \\frac{E_t}{\\text{true}} (\\text{often}\\times 100\\%)$$\n\n:::\n\n## Absolute and relative error (approx.)\n\nWe rarely know the true value (why approximate what we know exactly?)\n\n:::{.fragment}\nThe *approximate* absolute error, $E_a$ is:\n\n$$E_a = \\text{current approx} - \\text{previous approx}$$\n:::\n\n\n\n:::{.fragment}\nThe approximate relative error, $\\epsilon_a$ is:\n\n$$\\epsilon_a = \\frac{E_a}{\\text{current approx}} (\\text{often}\\times 100\\%)$$\n:::\n\n\n## Key differences\n\nWith *approximate* errors:\n\n::: incremental\n* We do not need to know the true value\n* We must perform the calculation iteratively\n* We assume that our solution *converges*\n  * If it doesn't we likely have a problem with our model.\n:::\n\n\n## Example - $\\sqrt[3]{250}$\n\n::: {#68613975 .cell output-location='fragment' execution_count=1}\n``` {.python .cell-code code-line-numbers=\",|1|2|3|4,5|6\"}\nnum = 250.0; guess = 100.0 # find cubed root of \"num\" with initial \"guess\"\nfor i in range(10):\n    new_guess = (2 * guess + num / guess**2) / 3 # some approx. method\n    E_a = new_guess - guess # Approx. absolute error\n    e_a = E_a / new_guess  # Approx. relative error\n    guess = new_guess\n```\n:::\n\n\n:::{.fragment}\n\n::: {#d3740e88 .cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\nIter.       Guess        E_a     e_a(%)\n---------------------------------------\n1        66.675000 -33.3250   -49.98\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#cad82f87 .cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\n2        44.468745 -22.2063   -49.94\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#fa9f94b0 .cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\n3        29.687972 -14.7808   -49.79\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#2837e5a6 .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\n4        19.886530  -9.8014   -49.29\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#bd2e06f3 .cell execution_count=6}\n\n::: {.cell-output .cell-output-stdout}\n```\n5        13.468404  -6.4181   -47.65\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#8b02fbb7 .cell execution_count=7}\n\n::: {.cell-output .cell-output-stdout}\n```\n6         9.438331  -4.0301   -42.70\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#244bcd6b .cell execution_count=8}\n\n::: {.cell-output .cell-output-stdout}\n```\n7         7.227688  -2.2106   -30.59\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#299942ac .cell execution_count=9}\n\n::: {.cell-output .cell-output-stdout}\n```\n8         6.413676  -0.8140   -12.69\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#d422179a .cell execution_count=10}\n\n::: {.cell-output .cell-output-stdout}\n```\n9         6.301622  -0.1121    -1.78\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#2d41fe88 .cell execution_count=11}\n\n::: {.cell-output .cell-output-stdout}\n```\n10        6.299606  -0.0020    -0.03\n```\n:::\n:::\n\n\n:::\n\n\n## Example - cubed root of 250 (plot)\nVisualize the algorithm's convergence with a plot\n\n\n\n:::{.r-stretch}\n\n::: {#c06e60b3 .cell execution_count=13}\n\n::: {.cell-output .cell-output-display}\n![](error_definitions_files/figure-revealjs/cell-14-output-1.png){width=801 height=411 fig-align='center'}\n:::\n:::\n\n\n:::\n\n## Which to use?\n\nThink about each scenario critically.\n\n:::{.fragment}\nOften best to use an approximate relative error method ($\\epsilon_a$) when:\n:::\n\n::: incremental\n* Target unknown\n* Not converging near zero\n:::\n\n:::{.fragment}\nWhen converging to zero (known target), true absolute error method often best.\n:::\n\n",
    "supporting": [
      "error_definitions_files"
    ],
    "filters": [],
    "includes": {}
  }
}