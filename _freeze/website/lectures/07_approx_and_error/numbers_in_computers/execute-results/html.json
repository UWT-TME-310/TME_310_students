{
  "hash": "e7e7be119e8be8615625e73c76cceee0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Numbers in computers\"\nsubtitle: \"TME 310 - Computational Physical Modeling\"\nauthor: \n  - \"Lorne Arnold, PhD, PE\"\ninstitute: \"University of Washington Tacoma\"\nformat:\n  revealjs:\n      logo: \"\"\n---\n\n## Why `float`?\nPython's integer type is `int`. That makes sense.\n\nWhat about `float` for numbers with decimals?\n\n:::{.fragment}\n`float` is short for *floating point*. In a float, the decimal place is not always in the same position (it floats around)\n\n::: {#91370e09 .cell output-location='fragment' execution_count=1}\n``` {.python .cell-code code-line-numbers=\"1,2,3|4,5,6\"}\n# Floats where the decimal point is between the \"ones\" and \"tenths\" place\na = 1.0\nb = 0.01\n# Very large or very small floats will have decimals moved and use scientific notation:\nc = 11000000000000000000.0\nd = 0.0000000000000000022\nprint(f\"a: {a}; b: {b} \\n\")\nprint(f\"c: {c}; d: {d}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na: 1.0; b: 0.01 \n\nc: 1.1e+19; d: 2.2e-18\n```\n:::\n:::\n\n\n:::\n\n## Why decimal places float\nFloating point numbers have a maximum (and minimum) size. \nUsing scientific notation allows the decimal place to be moved and unused places to be ignored.\n\n:::{.fragment}\nBy default, Python's floats use 64 bits and are limited to 15 to 17 decimal places.\n:::\n\n:::{.fragment}\nSo, floats have\n\n::: incremental\n1. limits on precision\n\n2. variable limits on precision\n:::\n\n:::\n\n\n## Precision limitations\nIf we try to assign more precision to a float than it can hold, **information will be lost**.\nConsider the code below:\n\n:::{.fragment}\n\n::: {#84ec036c .cell output-location='fragment' execution_count=2}\n``` {.python .cell-code code-line-numbers=\"1,2,3\"}\nbig = 1230000000.0\nmed = 456.0\nsml = 0.0000000789\nprint(f\"big + med: {big + med} <--- data preserved\\n\")\nprint(f\"med + small: {med + sml} <--- data preserved\\n\")\nprint(f\"big + small: {big + sml} <--- data lost!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nbig + med: 1230000456.0 <--- data preserved\n\nmed + small: 456.0000000789 <--- data preserved\n\nbig + small: 1230000000.0 <--- data lost!\n```\n:::\n:::\n\n\n:::\n\n## Variable precision\nFloating point precision is variable (15 to 17 base-10 places) because they're stored as binary (base-2) numbers.\n\n:::{.fragment}\n\nThis can lead to some unexpected behaviors:\n\n::: {#53b40685 .cell output-location='fragment' execution_count=3}\n``` {.python .cell-code code-line-numbers=\"1,2,3\"}\nx = 1.1\ny = 2.2\nz = x + y\nprint(f\"z: {z}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nz: 3.3000000000000003\n```\n:::\n:::\n\n\n:::\n\n\n## Compare with caution\nThis can be especially important when using logical statements to control scripts.\n\n```{.python code-line-numbers=\",|1|2|3|4|5|,\"}\nx = 1.0\nwhile x != 0:\n    x -= 0.1\n    print(f\"The value of x is now {x}\")\nprint(\"I've exited the loop!\")\n```\n\n:::{.fragment}\n\n::: {#38a4cf37 .cell output-location='fragment' execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\nThe value of x is now 0.9\nThe value of x is now 0.8\nThe value of x is now 0.7000000000000001\nThe value of x is now 0.6000000000000001\nThe value of x is now 0.5000000000000001\nThe value of x is now 0.40000000000000013\nThe value of x is now 0.30000000000000016\nThe value of x is now 0.20000000000000015\nThe value of x is now 0.10000000000000014\nThe value of x is now 1.3877787807814457e-16\nThe value of x is now -0.09999999999999987\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#7f05619b .cell output-location='fragment' execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\n... You'll need to interrupt Python to get out of an infitinte loop!\n```\n:::\n:::\n\n\n:::\n\n## With looser conditions\nThe \"fix\" for this example is simple: use *looser conditions*.\n\n```{.python code-line-numbers=\",\"}\nx = 1.0\nwhile x > 0:\n    x -= 0.1\n    print(f\"The value of x is now {x}\")\nprint(\"I've exited the loop!\")\n```\n\n:::{.fragment}\n\n::: {#721cf00d .cell output-location='fragment' execution_count=6}\n\n::: {.cell-output .cell-output-stdout}\n```\nThe value of x is now 0.9\nThe value of x is now 0.8\nThe value of x is now 0.7000000000000001\nThe value of x is now 0.6000000000000001\nThe value of x is now 0.5000000000000001\nThe value of x is now 0.40000000000000013\nThe value of x is now 0.30000000000000016\nThe value of x is now 0.20000000000000015\nThe value of x is now 0.10000000000000014\nThe value of x is now 1.3877787807814457e-16\nThe value of x is now -0.09999999999999987\nI've exited the loop!\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "numbers_in_computers_files"
    ],
    "filters": [],
    "includes": {}
  }
}