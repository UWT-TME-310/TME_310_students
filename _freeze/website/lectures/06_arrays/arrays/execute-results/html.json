{
  "hash": "7b139eb8fa8f313424456eb1cbe4227f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Arrays\"\nsubtitle: \"TME 310 - Computational Physical Modeling\"\nauthor: \n  - \"Lorne Arnold, PhD, PE\"\ninstitute: \"University of Washington Tacoma\"\nformat:\n  revealjs:\n      logo: \"\"\n---\n\n# Arrays vs. lists\n\n# Lists\n\n## List contents\nRecall that lists are **ordered collections of objects**:\n\n::: {#fa09dcaf .cell output-location='fragment' execution_count=1}\n``` {.python .cell-code code-line-numbers=\"1|2,3,4\"}\nmy_list = [1, 2, \"three\", 4, False]\nprint(\"A)\", my_list[0])\nprint(\"B)\", my_list[-1])\nprint(\"C)\", my_list[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA) 1\nB) False\nC) [2, 'three']\n```\n:::\n:::\n\n\n:::{.fragment}\nLists can contain mixed data types\n:::\n\n## Working with lists\nPerforming operations on lists happens one element at a time\n```{.python code-line-numbers=\"1,2|3,4,5\"}\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = []\nfor x_value in x:\n  y_value = x_value ** 2\n  y.append(y_value)\n```\n\n## A mixed type issue\nEven though lists can **contain** mixed data types, not every operation we do will **work** with every data type\n\n::: {#6e355eb3 .cell output-location='fragment' execution_count=2}\n``` {.python .cell-code code-line-numbers=\"1,2|3,4,5\"}\nx = [1, 2, 3, 4, 5, 6, 7, 8, \"nine\"]  <--- mixed data types\ny = []\nfor x_value in x:\n  y_value = x_value ** 2              <--- will cause a problem here\n  y.append(y_value)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-cyan-fg\">  Cell </span><span class=\"ansi-green-fg\">In[2], line 1</span>\n<span class=\"ansi-red-fg\">    x = [1, 2, 3, 4, 5, 6, 7, 8, \"nine\"]  &lt;--- mixed data types</span>\n                                                     ^\n<span class=\"ansi-red-fg\">SyntaxError</span><span class=\"ansi-red-fg\">:</span> invalid syntax\n</pre>\n```\n:::\n\n:::\n:::\n\n\n# Arrays\n\n## Arrays with Numpy\n\nLike Matplotlib, Numpy is an external library that we can import and use in Python:\n```{.python}\nimport numpy as np\n```\n\n:::{.fragment .fade-in}\nNumpy allows us to create n-dimensional arrays.\n\n::: incremental\n* 1-D arrays (aka \"vectors\")\n* 2-D and higher (aka \"matrices\")\n\n:::\n\n:::\n\n:::{.fragment .fade-in}\nBut for today, just 1-D\n:::\n\n## Creating arrays from lists\n\nNumpy arrays can be created from lists using the `numpy.array()` function.\nNumpy will automatically convert data into compatible `dtype`s if possible.\n\n:::{.fragment .fade-in}\n\n::: {#a4b2aa92 .cell output-location='fragment' execution_count=3}\n``` {.python .cell-code code-line-numbers=\"|2,4,6|3,5,7\"}\nimport numpy as np\nlist_a = [1, 2, 3, 4, 5]       # <--- all integers\nlist_b = [6, 7, 8, 9, 10.]     # <--- mixed int/float\narray_a = np.array(list_a)\narray_b = np.array(list_b)\nprint(array_a, array_a.dtype)  # <--- all integers\nprint(array_b, array_b.dtype)  # <--- all floats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5] int64\n[ 6.  7.  8.  9. 10.] float64\n```\n:::\n:::\n\n\n:::\n\n## Other ways to create arrays\n\nNumpy has built in functions to create arrays:\n\n::: {#ab13665b .cell output-location='fragment' execution_count=4}\n``` {.python .cell-code code-line-numbers=\"|2,3|4,5,6\"}\nimport numpy as np\n# np.linspace(start, stop, number of points)\nx = np.linspace(0,100,6)\n# np.zeros(number of points) and np.ones(number of points)\ny = np.zeros(4)\nz = np.ones(5)\nprint(f\" x: {x}\\n\",f\"y: {y}\\n\",f\"z: {z}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n x: [  0.  20.  40.  60.  80. 100.]\n y: [0. 0. 0. 0.]\n z: [1. 1. 1. 1. 1.]\n```\n:::\n:::\n\n\n## Array contents\nWe can access array contents via *indexing* just like lists:\n\n::: {#39fe1e47 .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\nx: [  0.  20.  40.  60.  80. 100.] <--- defined on previous slide\n```\n:::\n:::\n\n\n::: {#d75efa71 .cell output-location='fragment' execution_count=6}\n``` {.python .cell-code}\n# Get the first element of x:\nx[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nnp.float64(0.0)\n```\n:::\n:::\n\n\n:::{.fragment}\n\n::: {#b1d6f755 .cell output-location='fragment' execution_count=7}\n``` {.python .cell-code}\n# Get the last element of x:\nx[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nnp.float64(100.0)\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#49934862 .cell output-location='fragment' execution_count=8}\n``` {.python .cell-code}\n# Get a slice of x from the second to the fourth element\nx[1:5]  # <--- Notice the ending index in a slice is NOT inclusive\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([20., 40., 60., 80.])\n```\n:::\n:::\n\n\n:::\n\n## Working with arrays\nUnlike lists, we can perform operations on **entire arrays at once**.\n\n::: {#8eb036bb .cell output-location='fragment' execution_count=9}\n``` {.python .cell-code code-line-numbers=\"1-6|8-10\"}\n########## List version #########\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = []\nfor x_value in x:\n  y_value = x_value ** 2\n  y.append(y_value)\n  \n######### Array version #########\nx_arr = np.array(x)\ny_arr = x_arr ** 2\nprint(f\"y_arr: {y_arr}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny_arr: [ 1  4  9 16 25 36 49 64 81]\n```\n:::\n:::\n\n\n## \n\n::: {#da9b6815 .cell output-location='fragment' execution_count=10}\n``` {.python .cell-code code-line-numbers=\"2|3|4,5,6\"}\nimport matplotlib.pyplot as plt \nimport numpy as np\ntime = np.linspace(0, 3, 500)\namplitude = np.sin(2 * np.pi * time)\nplt.plot(time, amplitude)\n```\n\n::: {.cell-output .cell-output-display}\n![](arrays_files/figure-revealjs/cell-11-output-1.png){width=813 height=411}\n:::\n:::\n\n\n",
    "supporting": [
      "arrays_files"
    ],
    "filters": [],
    "includes": {}
  }
}