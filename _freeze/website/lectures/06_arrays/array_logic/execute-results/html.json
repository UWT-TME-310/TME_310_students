{
  "hash": "d36dfe9ee3bf0b6acfeed1c321c88438",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Array logic\"\nsubtitle: \"TME 310 - Computational Physical Modeling\"\nauthor: \n  - \"Lorne Arnold, PhD, PE\"\ninstitute: \"University of Washington Tacoma\"\nformat:\n  revealjs:\n      logo: \"\"\n---\n\n## Logical expressions\n\nWe have already seen **logical expressions** in places like while loops:\n\n```{.python}\nwhile logical_expression:\n    # execute something\n```\n\nLogical expressions evaluate whether something is true or false.\nThey result in a **boolean** value (`True` or `False` in Python).\n\n:::{.fragment}\n\n::: {#f3ff668e .cell output-location='fragment' execution_count=1}\n``` {.python .cell-code code-line-numbers=\",|2|,\"}\nx = 0\nwhile x < 2:\n    print(x)\n    x += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n```\n:::\n:::\n\n\n:::\n\n## Array indexing\n\nWe've also seen that we can access specific portions of arrays with **indexing**.\n\n::: {#d2675a43 .cell output-location='fragment' execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nx = np.linspace(0,100,6)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[  0.  20.  40.  60.  80. 100.]\n```\n:::\n:::\n\n\n:::{.fragment}\nWe can access individual elements or slices:\n:::\n\n:::{.fragment}\n\n::: {#05176033 .cell execution_count=3}\n\n::: {.cell-output .cell-output-stdout}\n```\nx[0]: 0.0\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#00127c78 .cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\nx[-1]: 100.0\n```\n:::\n:::\n\n\n:::\n\n:::{.fragment}\n\n::: {#ce2af5ee .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\nx[2:4]: [40. 60.]\n```\n:::\n:::\n\n\n:::\n\n## Logical indexing\nLogical indexing combines these two ideas.\n\n* A **logical expression** with an array results in a **logical array** (sometimes called a **mask**):\n\n:::{.fragment}\n\n::: {#99170713 .cell output-location='fragment' execution_count=6}\n``` {.python .cell-code code-line-numbers=\",\"}\nx = np.array([1.32, 1.1, 0.3, 3.8, -5.2]) # <-- an array of random numbers\nlogical_array = x < 1\nprint(f\"logical_array: {logical_array}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlogical_array: [False False  True False  True]\n```\n:::\n:::\n\n\n:::\n\n\n:::{.fragment}\n* **Indexing** an array with a logical array returns *only the entries of the array where the logical array is `True`.*\n:::\n\n:::{.fragment}\n\n::: {#2eee8fed .cell output-location='fragment' execution_count=7}\n``` {.python .cell-code code-line-numbers=\",\"}\nx[logical_array]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([ 0.3, -5.2])\n```\n:::\n:::\n\n\n:::\n\n## Logical AND/OR with arrays\nWe can combine logical tests in numpy with the bitwise \"AND\" operator, `&`, or the bitwise \"OR\" operator, `|`.\n\n:::{.fragment}\nThe result of logical tests connected by `&` is only `True` if BOTH statements are true. \nThe result of logical tests connected by `|` is `True` if EITHER statements are true.\n:::\n\n:::{.fragment}\n\n::: {#d66fed17 .cell output-location='fragment' execution_count=8}\n``` {.python .cell-code code-line-numbers=\",\"}\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n# What values of arr are greater than 3 AND less than 7?\nprint(arr[(arr > 3) & (arr < 7)]) # <--- each test in ()!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4 5 6]\n```\n:::\n:::\n\n\n::: {#8a64061d .cell output-location='fragment' execution_count=9}\n``` {.python .cell-code code-line-numbers=\",\"}\n# What values of arr are greater than 6 OR less than 2?\nprint(arr[(arr > 6) | (arr < 2)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 1  7  8  9 10]\n```\n:::\n:::\n\n\n:::\n\n## Application with related arrays\nLogical indexing is particularly powerful with *related arrays*.\nFor example:\n\n> If $y(x) = 1.27^{2.3x}$, what is the minimum value of $x$ to result in a value of $y$ greater than $4.0$?\n\n::: {.fragment}\nSteps to solving with logical indexing:\n\n1. Create a **mask** using the test condition on $y$\n2. Apply the mask to the **related array**, $x$\n3. Select the first^[Or last, depending on how the mask and test condition are applied] entry in the masked version of $x$\n\n:::\n\n## Solve with logical array\n\n::: {#0b25476c .cell output-location='fragment' execution_count=10}\n``` {.python .cell-code code-line-numbers=\"1,2,3|4,5|6,7|8,9\"}\n# Initial arrays x and y:\nx = np.linspace(0,4)\ny = 1.27**(2.3*x)\n# Create a mask using the test condition on y:\nlogical_mask = y > 4.0\n# Apply the mask to the related array, x:\nx_masked = x[logical_mask]\n# Select the first entry in the masked version of x:\nanswer = x_masked[0]\nprint(f\"x_masked: {x_masked}\")\nprint(f\"answer: {answer:.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx_masked: [2.53061224 2.6122449  2.69387755 2.7755102  2.85714286 2.93877551\n 3.02040816 3.10204082 3.18367347 3.26530612 3.34693878 3.42857143\n 3.51020408 3.59183673 3.67346939 3.75510204 3.83673469 3.91836735\n 4.        ]\nanswer: 2.53\n```\n:::\n:::\n\n\n:::{.fragment}\nWhat about values of `x` *slightly* smaller than `2.53061224`?\n:::\n\n\n## Plots with masked arrays\nSee if you can re-create the plots of these array masking examples: *(hint: some use `np.random.rand()`)*\n\n\n\n::: {.panel-tabset}\n\n### Example 1\n\n::: {#1c180732 .cell execution_count=12}\n\n::: {.cell-output .cell-output-display}\n![](array_logic_files/figure-revealjs/cell-13-output-1.png){width=799 height=429 fig-align='center'}\n:::\n:::\n\n\n### Example 2\n\n::: {#362d1435 .cell execution_count=13}\n\n::: {.cell-output .cell-output-display}\n![](array_logic_files/figure-revealjs/cell-14-output-1.png){width=832 height=429 fig-align='center'}\n:::\n:::\n\n\n### Example 3\n\n::: {#33f4297f .cell execution_count=14}\n\n::: {.cell-output .cell-output-display}\n![](array_logic_files/figure-revealjs/cell-15-output-1.png){width=832 height=429 fig-align='center'}\n:::\n:::\n\n\n### Example 4\n\n::: {#99774c50 .cell execution_count=15}\n\n::: {.cell-output .cell-output-display}\n![](array_logic_files/figure-revealjs/cell-16-output-1.png){width=821 height=429 fig-align='center'}\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "array_logic_files"
    ],
    "filters": [],
    "includes": {}
  }
}