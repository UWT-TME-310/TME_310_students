{
  "hash": "3fc0f5d808b947d76b3af0abe7dc733b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Python Basics for Computational Physical Modeling\nexecute:\n  enabled: true\n  echo: true\n  error: true\n  output: true\njupyter: python3\nformat: \n  html:\n    code-overflow: wrap\n---\n\nWelcome to Python! This notebook will introduce you to some basic Python concepts that you'll use in TME 310.\n\n## What will be covered\n\n1.  **Data Types** - Kinds of information\n2.  **Variables** - Where information is stored\n3.  **Numbers and Math** - How calculations are done\n4.  **Strings** - Text objects\n5.  **Lists** - A built in way to organize data\n6.  **Conditionals** - How we ask questions about data\n7.  **Loops** - Doing repetitive things automatically\n\n## Data Types\n\nThere are different kinds of information we can store in Python - these are called **types**. Python has several built in data types. Today, we'll cover some of the most commonly-used ones:\n\n-   `int` (numeric integers)\n-   `float` (numeric real numbers)\n-   `bool` (true or false)\n-   `string` (text)\n-   `list` (collection of other objects)\n\n### `int`\n\nAn `int` is an integer value (e.g., `1` or `-395`). In Python, we can check the type of an object with the built-in `type()` function.\n\n::: {#cell-1 .cell execution_count=1}\n``` {.python .cell-code}\n# An integer\ntype(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nint\n```\n:::\n:::\n\n\n::: {#cell-2 .cell execution_count=2}\n``` {.python .cell-code}\n# Another integer\ntype(-395)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nint\n```\n:::\n:::\n\n\n### `float`\n\nA `float` is another numeric data type in Python. Unlike an `int`, a `float` is a real number that can have several decimal places. For example:\n\n::: {#cell-4 .cell execution_count=3}\n``` {.python .cell-code}\n# A floating point number\ntype(9.81)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nfloat\n```\n:::\n:::\n\n\nNote that any number with a decimal place will be interpreted as a `float` by Python, even if there's nothing after the decimal place:\n\n::: {#cell-6 .cell execution_count=4}\n``` {.python .cell-code}\n# This is also a floating point number\ntype(1.)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nfloat\n```\n:::\n:::\n\n\n### `bool`\n\nA `bool` (boolean) represents True or False values. These are useful for yes/no questions.\n\n::: {#cell-8 .cell execution_count=5}\n``` {.python .cell-code}\n# In Python True and False are capitalized\ntype(True)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nbool\n```\n:::\n:::\n\n\n::: {#cell-9 .cell execution_count=6}\n``` {.python .cell-code}\ntype(False)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nbool\n```\n:::\n:::\n\n\n### `str`\n\nA string (or `str`) represents text. Strings are surrounded by quotes. Either single or double quotes can be used to surround strings:\n\n::: {#cell-11 .cell execution_count=7}\n``` {.python .cell-code}\n# A double-quoted string\ntype(\"hello\")\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nstr\n```\n:::\n:::\n\n\n::: {#cell-12 .cell execution_count=8}\n``` {.python .cell-code}\n# A single-quoted string\ntype('world')\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nstr\n```\n:::\n:::\n\n\nIt's considered best practice to use double quotes for strings even though single quotes are accepted by Python. More importantly, whichever kind of quote starts the string has to be used to close it, or you'll get a syntax error!\n\n::: {#cell-14 .cell execution_count=9}\n``` {.python .cell-code}\n# This will cause an error!\ntype('mismatch\")\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-cyan-fg\">  Cell </span><span class=\"ansi-green-fg\">In[9], line 2</span>\n<span class=\"ansi-red-fg\">    type('mismatch\")</span>\n         ^\n<span class=\"ansi-red-fg\">SyntaxError</span><span class=\"ansi-red-fg\">:</span> unterminated string literal (detected at line 2)\n</pre>\n```\n:::\n\n:::\n:::\n\n\n### `list`\n\nA `list` is a collection of other objects. Lists are surrounded by square brackets `[]` with their elements separated by commas.\n\n::: {#cell-16 .cell execution_count=10}\n``` {.python .cell-code}\n# A list of integers\ntype([1, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nlist\n```\n:::\n:::\n\n\nThe elements of a list don't need to be the same type.\n\n::: {#cell-18 .cell execution_count=11}\n``` {.python .cell-code}\n# A list of mixed types\ntype([1, \"two\", 3.0, True])\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nlist\n```\n:::\n:::\n\n\n::: {#cell-19 .cell execution_count=12}\n``` {.python .cell-code}\n# Even another list:\ntype([1, 2, [\"I'm\", \"a\", \"list\"], 4])\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nlist\n```\n:::\n:::\n\n\n## Variables\n\nVariables are names that refer to objects. We create variables using the assignment operator `=`.\n\n::: {#cell-21 .cell execution_count=13}\n``` {.python .cell-code}\nx = 5\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n5\n```\n:::\n:::\n\n\nJupyter will automatically display the output of the last line in a cell if it is an expression or variable, and not assigned to anything. That's why writing `x` on the last line in the cell above resulted in the value assigned to `x` being displayed.\n\nBut that automatic display only happens for the **last line** in a cell.\n\n::: {#cell-23 .cell execution_count=14}\n``` {.python .cell-code}\n# No output here\ny = 10\ny\nz = 37\n```\n:::\n\n\nIn general, it's better to explicitly tell Python what to display with the `print()` function, which does not need to be on any particular line.\n\n::: {#cell-25 .cell execution_count=15}\n``` {.python .cell-code}\n# Printing the value of y that wasn't shown above\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n```\n:::\n:::\n\n\nAny data type can be assigned to a variable:\n\n::: {#cell-27 .cell execution_count=16}\n``` {.python .cell-code}\ncourse = \"TME 310A\"\nstudents = 25\nmax_grade = 4.0\nfun = True\n```\n:::\n\n\nThe value of one variable can be assigned to another, too:\n\n::: {#cell-29 .cell execution_count=17}\n``` {.python .cell-code}\na = 5\nprint(a)\n\n# Assigning the value of a to b\nb = a\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n5\n```\n:::\n:::\n\n\n::: callout-note\n## Caution\n\nIn the case above, `a` and `b` are both of type `int`. If the value of `a` is changed at some future point in the code, the value of `b` will be unaffected. But this is **not the case** for all data types, as we'll see in a few sections.\n:::\n\n## Numbers and Math\n\nMost arithmetic operations in Python act like you'd expect. For example:\n\n::: {#cell-31 .cell execution_count=18}\n``` {.python .cell-code}\n# Addition\nw = 20 + 34\nprint(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n54\n```\n:::\n:::\n\n\n::: {#cell-32 .cell execution_count=19}\n``` {.python .cell-code}\n# Subtraction\nx = 10 - 4\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\n::: {#cell-33 .cell execution_count=20}\n``` {.python .cell-code}\n# Multiplication\ny = 3 * 7\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n21\n```\n:::\n:::\n\n\n::: callout-note\n## Caution\n\nThis is a good place to note one of the potential sources of error in Jupyter notebooks.\n\nNow that we've just overwritten the variable `y` with a new value, go back to the **Variables** section and run the cell that contains `print(y)`. Python will always interpret variables based on their values **at the time of execution**, which may not reflect the expected values based on a linear reading of the notebook.\n:::\n\nDivision in Python will often look how you'd expect, but there are some details worth examining. The basic division operator is `/`, which works on `int` and `float` data types, but always returns a `float`. This is because it converts anything it's operating on into a `float` before performing division. So, even if it's used between two integers and the result could be represented as an integer, the resulting data type will be `float`.\n\n::: {#cell-35 .cell execution_count=21}\n``` {.python .cell-code}\n# Division\nz = 15 / 3\nprint(z) # z is a float even though 15 can be divided by 3 evenly\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.0\n```\n:::\n:::\n\n\nTo perform integer division in Python, use the `//` operator. This performs division and returns the result rounded down to the next smallest whole number.\n\n::: {#cell-37 .cell execution_count=22}\n``` {.python .cell-code}\n# Returns an integer result (no rounding needed)\n15 // 3\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n5\n```\n:::\n:::\n\n\n::: {#cell-38 .cell execution_count=23}\n``` {.python .cell-code}\n# This result gets rounded to the next smallest whole number\n13 // 3\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n4\n```\n:::\n:::\n\n\nWhen you first learned to divide, you probably used \"remainders\" when numbers didn't divide evenly. So the answer to `13` divided by `3` would have been `4` remainder `1`. The integer division operator in Python ignores the remainder, but another useful operator provides it - the modulo operator: `%`.\n\n::: {#cell-40 .cell execution_count=24}\n``` {.python .cell-code}\n# The remainder after integer division\n13 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n1\n```\n:::\n:::\n\n\nThe `**` operator means \"to the power of\". So `2 ** 3` means `2` to the power of `3`.\n\n::: {#cell-42 .cell execution_count=25}\n``` {.python .cell-code}\n2 ** 3\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n8\n```\n:::\n:::\n\n\n## Strings\n\nAlthough strings are text, not numbers, some of the operators discussed above can be used with strings. But, of course, they have different meanings when text is involved.\n\nFor example, \"adding\" two strings sticks the two pieces of text together:\n\n::: {#cell-44 .cell execution_count=26}\n``` {.python .cell-code}\n\"hello\" + \" world\"\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n'hello world'\n```\n:::\n:::\n\n\nMultiplying a string creates multiple copies of the original text and sticks them all together:\n\n::: {#cell-46 .cell execution_count=27}\n``` {.python .cell-code}\n\" alright \" * 3\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n' alright  alright  alright '\n```\n:::\n:::\n\n\nOther operators (like `-` or `/`) don't have unique meaning with strings, so they aren't allowed. Trying to use them will result in an error:\n\n::: {#cell-48 .cell execution_count=28}\n``` {.python .cell-code}\n\"hello\" - \" world\"  # This will cause an error\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[28], line 1</span>\n<span class=\"ansi-green-fg\">----&gt; 1</span> <span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">\"</span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">hello</span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">\"</span><span class=\"ansi-yellow-bg\"> </span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">-</span><span class=\"ansi-yellow-bg\"> </span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">\"</span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\"> world</span><span style=\"color:rgb(175,0,0)\" class=\"ansi-yellow-bg\">\"</span>  <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will cause an error</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: unsupported operand type(s) for -: 'str' and 'str'</pre>\n```\n:::\n\n:::\n:::\n\n\nThe `len()` function returns the number of characters in a string:\n\n::: {#cell-50 .cell execution_count=29}\n``` {.python .cell-code}\nlen(\"This is a string. It's not super long, but it's long enough that I don't want to count the characters myself.\")\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n109\n```\n:::\n:::\n\n\nOne of the most useful features Python has for strings is the \"F-string\". With F-strings, you can put variables inside your strings (inside curly braces `{}`) and get the variable value inserted into your string.\n\n::: {#cell-52 .cell execution_count=30}\n``` {.python .cell-code}\ncourse = \"TME 310A\"\nstudents = 25\nmax_grade = 4.0\n\nprint(f\"There are {students} students registered for {course}. The highest grade you can get is {max_grade}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThere are 25 students registered for TME 310A. The highest grade you can get is 4.0\n```\n:::\n:::\n\n\nStrings are **indexed**, which means that each character in the string has a numbered position (called an index). You can access the $n$th character in a string putting the index you want in square brackets after the string:\n\n::: {#cell-54 .cell execution_count=31}\n``` {.python .cell-code}\nmy_string = \"abstraction\"\nmy_string[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n's'\n```\n:::\n:::\n\n\nDepending on what languages you've programmed in before, you may have expected `my_string[2]` to return `b` since that's the 2nd character in the string. But Python is a \"zero-indexed\" language, so counting always starts at zero. To get the first character in the string, we need to put `0` in square brackets:\n\n::: {#cell-56 .cell execution_count=32}\n``` {.python .cell-code}\nmy_string[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n'a'\n```\n:::\n:::\n\n\nTrying to access an index past the end of the string will cause an error:\n\n::: {#cell-58 .cell execution_count=33}\n``` {.python .cell-code}\ntoo_far = len(my_string)\nmy_string[too_far] # This will cause an error\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">IndexError</span>                                Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[33], line 2</span>\n<span class=\"ansi-green-fg ansi-bold\">      1</span> too_far <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(0,135,0)\">len</span>(my_string)\n<span class=\"ansi-green-fg\">----&gt; 2</span> <span class=\"ansi-yellow-bg\">my_string</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-yellow-bg\">too_far</span><span class=\"ansi-yellow-bg\">]</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will cause an error</span>\n\n<span class=\"ansi-red-fg\">IndexError</span>: string index out of range</pre>\n```\n:::\n\n:::\n:::\n\n\nNotice that the trying to access and index equal to the length of the string causes `IndexError: string index out of range` because the indexing starts at 0! That means that the last entry in the string will have the value `len(my_string) - 1`.\n\nIn fact, Python supports negative indexing without needing to find the length of the string. The last entry in the string has index `-1`; and the second to last entry has index `-2`, and so on.\n\n::: {#cell-60 .cell execution_count=34}\n``` {.python .cell-code}\nmy_string[-1] # This will give the last character of the string\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n'n'\n```\n:::\n:::\n\n\n::: {#cell-61 .cell execution_count=35}\n``` {.python .cell-code}\nmy_string[-2] # This will give the second to last character of the string\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n'o'\n```\n:::\n:::\n\n\n## Lists\n\nWe've already seen that lists are containers that hold objects. Now we'll discuss how to interact with these containers.\n\nLike strings, lists are indexed data types, so we can use the indexing syntax to access specific values in a list:\n\n::: {#cell-63 .cell execution_count=36}\n``` {.python .cell-code}\ncolors = [\"red\", \"green\", \"blue\"]\n\n# Print the first item in the list:\nprint(colors[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nred\n```\n:::\n:::\n\n\nOne of the key differences between lists and strings is that lists are **mutable**, while strings are **immutable**. This means that you can change the value of an entry in a list, but you can't with a string:\n\n::: {#cell-65 .cell execution_count=37}\n``` {.python .cell-code}\n# Change the second color from \"green\" to \"yellow\":\ncolors[1] = \"yellow\"\nprint(colors)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['red', 'yellow', 'blue']\n```\n:::\n:::\n\n\n::: {#cell-66 .cell execution_count=38}\n``` {.python .cell-code}\n# Trying to change one of the characters in a string will cause an error:\nmy_string[0] = \"A\" # This will cause an error\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[38], line 2</span>\n<span class=\"ansi-green-fg ansi-bold\">      1</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># Trying to change one of the characters in a string will cause an error:</span>\n<span class=\"ansi-green-fg\">----&gt; 2</span> <span class=\"ansi-yellow-bg\">my_string</span><span class=\"ansi-yellow-bg\">[</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">0</span><span class=\"ansi-yellow-bg\">]</span> <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">A</span><span style=\"color:rgb(175,0,0)\">\"</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will cause an error</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: 'str' object does not support item assignment</pre>\n```\n:::\n\n:::\n:::\n\n\nCopying A major implication of whether an object is mutable or not is how Python handles **copies** of the object. We saw previously that when we made a copy of an integer variable, changing the original variable did not change the copy. This kind of copying is called **deep** copying. It's the default behavior for immutable objects in Python so the same applies to strings:\n\n::: {#cell-68 .cell execution_count=39}\n``` {.python .cell-code}\n# Make a string and copy it\noriginal_string = \"TME 310A\"\ncopied_string = original_string\nprint(original_string)\nprint(copied_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTME 310A\nTME 310A\n```\n:::\n:::\n\n\n::: {#cell-69 .cell execution_count=40}\n``` {.python .cell-code}\n# Change the original string\noriginal_string = \"TME 310B\"\n\n# The copy is unchanged\nprint(original_string)\nprint(copied_string)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTME 310B\nTME 310A\n```\n:::\n:::\n\n\nBut since lists are mutable, when they're copied, Python makes what's called a **shallow** copy. A shallow copy points to the original rather than reproducing it. This means that a change to the original will immediately cause a change in the \"copy\". And, strangely enough, a change in the copy will immediately change the original!\n\n::: {#cell-71 .cell execution_count=41}\n``` {.python .cell-code}\n# Make a list and copy it\noriginal_list = [ 1, 2, 3 ]\ncopied_list = original_list\nprint(original_list)\nprint(copied_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n[1, 2, 3]\n```\n:::\n:::\n\n\n::: {#cell-72 .cell execution_count=42}\n``` {.python .cell-code}\n# Change the original list\noriginal_list[0] = 99\n\n# Both the original and the \"copy\" are changed!\nprint(original_list)\nprint(copied_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[99, 2, 3]\n[99, 2, 3]\n```\n:::\n:::\n\n\n::: {#cell-73 .cell execution_count=43}\n``` {.python .cell-code}\n# Change the copy\ncopied_list[-1] = -5\n\n# The original gets changed too!\nprint(original_list)\nprint(copied_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[99, 2, -5]\n[99, 2, -5]\n```\n:::\n:::\n\n\n## Conditionals\n\nConditionals let you make decisions in your code with `if`, `elif`, and `else` statements. Often these use **boolean** comparators which evaluate a statement and return whether it is true or false. Python's boolean comparators are\n\n| Boolean comparator | Meaning                  |\n|--------------------|--------------------------|\n| `>`                | greater than             |\n| `<`                | less than                |\n| `>=`               | greater than or equal to |\n| `<=`               | less than or equal to    |\n| `!=`               | not equal to             |\n| `==`               | equal to                 |\n\n::: {#cell-75 .cell execution_count=44}\n``` {.python .cell-code}\n# Create two variables and check whether one is greater than the other\na = 5\nb = 10\na > b\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\nFalse\n```\n:::\n:::\n\n\nBoolean comparators and conditional statements allow us to change the behavior of Python scripts depending on the values of certain variables. Conditional statements (like the `if` statement) have three parts: 1. The keyword 2. The test condition followed by a colon `:` 3. An indented codeblock that is executed if the test condition is `True`\n\nFor example:\n\n::: {#cell-77 .cell execution_count=45}\n``` {.python .cell-code}\ntemperature = 65                # a variable representing the temperature\n\nif temperature > 70:            # The \"if\" keyword, the test condition, and a colon\n    print(\"It's warm outside\")  # An indented codeblock that runs if the test condition is True\n```\n:::\n\n\nThe other conditional statements, `else` and `elif` (short for \"else if\") use the same syntax as the `if` statement, but the must come after an `if` or `elif` statement. They can be used to execute different indented codeblocks under different circumstances.\n\nFor example:\n\n::: {#cell-79 .cell execution_count=46}\n``` {.python .cell-code}\ntemperature = 65  \n\nif temperature > 70: \n    print(\"It's warm outside\")\nelif temperature < 50:\n    print(\"It's cold outside\")\nelse:\n    print(\"It's a nice day\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIt's a nice day\n```\n:::\n:::\n\n\n## Loops\n\nLoops let you repeat code. The `for` loop goes through each item in an iterable object, like a list:\n\n::: {#cell-81 .cell execution_count=47}\n``` {.python .cell-code}\nfruits = [\"apple\", \"banana\", \"orange\"]\n\nfor fruit in fruits:\n    print(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\napple\nbanana\norange\n```\n:::\n:::\n\n\nThe `range()` function creates an iterable sequence of numbers that can be used to control a `for` loop:\n\n::: {#cell-83 .cell execution_count=48}\n``` {.python .cell-code}\nfor i in range(5):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n```\n:::\n:::\n\n\nThe `while` loop repeats as long as a condition is True.\n\n::: {#cell-85 .cell execution_count=49}\n``` {.python .cell-code}\ncount = 0\n\nwhile count < 3:\n    print(f\"Count is {count}\")\n    count = count + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCount is 0\nCount is 1\nCount is 2\n```\n:::\n:::\n\n\nThe example above is not a great use of a `while` loop because the same thing can be accomplished with a `for` loop and `while` loops have the potential to run forever (or until you manually force the computer to stop). That's called an \"infinite loop\" and can be a pain if triggered accidentally in your code. In the code above, if you left out the list line in the loop, for example, the value of count would never increase and the conditional test (`count < 3`) would always be `True` and the loop would run forever.\n\nIt's best to reserve `while` loops for situations where you're uncertain how many iterations are needed.\n\n",
    "supporting": [
      "02_python_basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}